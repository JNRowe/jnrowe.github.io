<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://jnrowe.github.io/</id>
  <title>JNRowe - Posts tagged sql</title>
  <updated>2021-03-29T21:43:26.046192+00:00</updated>
  <link href="https://jnrowe.github.io/"/>
  <link href="https://jnrowe.github.io/blog/tag/sql/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.17">ABlog</generator>
  <subtitle>Ramblings of a tired mind</subtitle>
  <entry>
    <id>https://jnrowe.github.io/thoughts/i_have_a_secret.html</id>
    <title>I have a secret</title>
    <updated>2019-05-24T00:00:00+01:00</updated>
    <author>
      <name>James Rowe</name>
    </author>
    <content type="html">&lt;div class="section" id="i-have-a-secret"&gt;

&lt;p&gt;A terrible secret haunts me, at times daily… I have virtually &lt;em&gt;no&lt;/em&gt; &lt;a class="reference external" href="https://en.m.wikipedia.org/wiki/SQL"&gt;SQL&lt;/a&gt; skills.&lt;/p&gt;
&lt;p&gt;Somehow I’m nearly twenty years in to my career and I possess so little &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt;
knowledge that I need to thumb a reference every single time its use passes my
desk.&lt;/p&gt;
&lt;p&gt;The reason this hasn’t mattered as much as it should is simply that I’ve been
terribly lucky.  When working on systems that require a lot of &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; use there
are &lt;em&gt;amazing&lt;/em&gt; &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; geniuseseses who sneak around behind the scenes making
things awesome.  They often leave cute little love notes in the commit messages
alerting me to the wonders of documentation, and on occasion even self-upping
their owed beer count at the same time.&lt;/p&gt;
&lt;img alt="Sad reality of SQL knowledge" class="align-left" src="../../_images/sql_venn.png" /&gt;
&lt;p&gt;I’ll submit that I’m not &lt;em&gt;entirely&lt;/em&gt; ignorant of the domain.  I routinely use
&lt;strong class="command"&gt;sqlite3&lt;/strong&gt; at the command line for inspecting configuration files and
local application databases.  I’ve written a few apps that use &lt;a class="reference external" href="http://www.sqlite.org/"&gt;sqlite&lt;/a&gt; for
their data storage, or that query remote &lt;a class="reference external" href="http://www.postgresql.org/"&gt;postgresql&lt;/a&gt; servers for reporting.
I know &lt;em&gt;what&lt;/em&gt; an &lt;a class="reference external" href="https://en.m.wikipedia.org/wiki/N+1_Select_Problem"&gt;n+1 problem&lt;/a&gt; is, but I’ll still create them through lack of
forethought from time to time.  It is just that my knowledge stops right about
there.&lt;/p&gt;
&lt;div class="section" id="orm-usage"&gt;
&lt;h2&gt;&lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; usage&lt;/h2&gt;
&lt;p&gt;The number one thing that has kept me away from a deeper understanding of &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt;
is &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt;s.  Let us be honest, most of the time we interact with &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; fronted
databases it is from a language where we are treating &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; as nothing more
than a &lt;abbr title="Domain Specific Language"&gt;DSL&lt;/abbr&gt;.  Often, it would feel fair to say we treat it this way with
little to no interest in what is going on behind the scenes.&lt;/p&gt;
&lt;p&gt;If you’re using &lt;a class="reference external" href="http://www.python.org/"&gt;Python&lt;/a&gt; — like I was when I decided to write this — you’re
probably reaching for &lt;a class="reference external" href="http://www.sqlalchemy.org/"&gt;sqlalchemy&lt;/a&gt; to integrate databases in to your codebase.
It is spectacular, especially when combined with &lt;a class="reference external" href="https://bitbucket.org/zzzeek/alembic"&gt;alembic&lt;/a&gt; for migration
management.&lt;/p&gt;
&lt;p&gt;Using a well designed &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; allows us to free ourselves from a lot of the
mental overhead of dealing with databases; they’ll handle connections,
transactions, save points, etc.  They’ll almost always handle the
idiosyncrasies of different databases too, which is fantastic when you’re
developing against &lt;a class="reference external" href="http://www.sqlite.org/"&gt;sqlite&lt;/a&gt; and deploying to a large scale &lt;a class="reference external" href="http://www.postgresql.org/"&gt;postgresql&lt;/a&gt;
installation&lt;a class="footnote-reference brackets" href="#id3" id="id1"&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another effect, which admittedly may be a by-product of how I commonly use
&lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt;s, is the reconnection of constraints to models.  It feels all too common
in many non-&lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; projects to see duplication of constraint handling.  We’ll
see constraints defined in the &lt;abbr title="Data Definition Language"&gt;DDL&lt;/abbr&gt; via &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt;
and again in the codebase’s host language.  We, as relational database users,
know that this duplication violates the spirit of a couple of Codd’s rules:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;&lt;p&gt;A single language must be able to define data, views, integrity
constraints, authorization, transactions, and data manipulation.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;Integrity constraints must be available and stored in the metadata, not in
an application program.&lt;/p&gt;
&lt;p class="attribution"&gt;—Dr. E. F. Codd&lt;/p&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;However, eventually we end up hoisting a lot of constraint handling in to an
application as it can both improve and simplify error handling logic.  And then
over time they &lt;em&gt;will&lt;/em&gt; become out of sync in various ways, either through
negligence or simple oversight.&lt;/p&gt;
&lt;p&gt;When we allow ourselves to define our system, constraints included, within the
realms of an &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; we can rely on the automatic transfer of model design to the
underlying database.  I feel it is important to note that Codd never appears to
suggest we use two languages for database access and applications, just that
a single language can do &lt;em&gt;everything&lt;/em&gt; within our database and a &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; seems to
fit the bill.  It is just that people have coalesced around &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; as &lt;em&gt;the only&lt;/em&gt;
interface to relational databases over the decades, and as such we end up using
two distinct languages far more often that we perhaps ought.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="editing"&gt;
&lt;h2&gt;Editing&lt;/h2&gt;
&lt;p&gt;When working with &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; without an &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; things change &lt;em&gt;greatly&lt;/em&gt;.  You find
yourself having to consciously flip back and forward between mental models of
how you’re processing your data, and personally I can find that quite
challenging at times.  I mean yes, at the top-level we may be &lt;em&gt;thinking&lt;/em&gt; in
unison for both our application languages and &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt;, but we’re often falling
back to applying a manual remapping of the derived table when we’re processing
the results.  We’re literally hand rolling the work that an already written
— and hopefully well tested — &lt;abbr title="Object Relational Mapping"&gt;ORM&lt;/abbr&gt; can already perform for us.&lt;/p&gt;
&lt;p&gt;Even the little things can be jarring.  One that surprises me is watching
people work with &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; embedded in other source files doing so in editors that
don’t really help such usage.  Everything is fine in &lt;a class="reference external" href="http://www.vim.org/"&gt;vim&lt;/a&gt;/&lt;a class="reference external" href="http://www.gnu.org/software/emacs/"&gt;emacs&lt;/a&gt; land, where
one can apply syntax highlighting and linting to specific regions of a file&lt;a class="footnote-reference brackets" href="#id4" id="id2"&gt;2&lt;/a&gt;.  For other editors, and most &lt;abbr title="Integrated Development Environment"&gt;IDEs&lt;/abbr&gt;, you’re often left floundering in a heap of unstructured literal
strings peppered all over the place.&lt;/p&gt;
&lt;img alt="Multi-language highlighting in vim" src="../../_images/vim_py_sql.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="wait-am-i-talking-myself-out-of-learning"&gt;
&lt;h2&gt;Wait, am I talking myself out of learning?&lt;/h2&gt;
&lt;p&gt;I know this has sounded like a sweetheart letter aimed at
&lt;a class="reference external" href="http://www.sqlalchemy.org/"&gt;sqlalchemy&lt;/a&gt;/&lt;a class="reference external" href="http://www.rubyonrails.org/"&gt;activerecord&lt;/a&gt;/&lt;a class="reference external" href="http://www.codesynthesis.com/products/odb"&gt;odb&lt;/a&gt;, but it isn’t meant that way.  Okay, it kinda of
is.  However, I want to know more.&lt;/p&gt;
&lt;p&gt;I’m tired of needing to enlist the help of others when I want a deeper
understanding of what is causing slowdowns with complex queries, or having to
reach for a manual to remember little things like how to manage collation
rules.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="acceptance"&gt;
&lt;h2&gt;Acceptance&lt;/h2&gt;
&lt;p&gt;Now that I’ve accepted this fact enough to scribble this note I’m going to do
something to fix it.&lt;/p&gt;
&lt;p&gt;I’ve picked up a couple of books, and I’m going to immerse myself in the
experience for a little while.  If you have advice or pointers to resources,
then please drop me a &lt;a class="reference external" href="mailto:jnrowe&amp;#37;&amp;#52;&amp;#48;gmail&amp;#46;com"&gt;mail&lt;/a&gt;.&lt;/p&gt;
&lt;p class="rubric"&gt;Footnotes&lt;/p&gt;
&lt;dl class="footnote brackets"&gt;
&lt;dt class="label" id="id3"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="#id1"&gt;1&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;That is probably a good hint as to why I’m still capable of producing
expensive &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;n+1&lt;/span&gt;&lt;/code&gt; queries, even when I know what they are.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class="label" id="id4"&gt;&lt;span class="brackets"&gt;&lt;a class="fn-backref" href="#id2"&gt;2&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;p&gt;My opinion being that the narrow region feature of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;emacs&lt;/span&gt;&lt;/code&gt;, and the
excellent &lt;a class="reference external" href="https://github.com/chrisbra/NrrwRgn"&gt;vim substitute&lt;/a&gt;, are the gold standard for working with
complex &lt;abbr title="Structured Query Language"&gt;SQL&lt;/abbr&gt; embedded in another language’s files.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    <link href="https://jnrowe.github.io/thoughts/i_have_a_secret.html" rel="alternate"/>
    <category term="databases" label="databases"/>
    <category term="learning" label="learning"/>
    <category term="sql" label="sql"/>
    <published>2019-05-24T00:00:00+01:00</published>
  </entry>
</feed>
